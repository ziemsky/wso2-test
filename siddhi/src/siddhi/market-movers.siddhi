@App:name("market-movers")


@source(
  type="kafka",
  bootstrap.servers="localhost:9092",
  topic.list="bets",
  partition.no.list="0",
  group.id="market-movers_bets",
  threading.option="single.thread",
  @map(
    type = 'json'
))
define stream Bets(selection string, user string);


@source(
  type="kafka",
  bootstrap.servers="localhost:9092",
  topic.list="marketPriceChanges",
  partition.no.list="0",
  group.id="market-movers_price-changes",
  threading.option="single.thread",
  @map(
    type = 'json'
))
define stream PriceChanges(selection string, odds int);


@sink(
  type="kafka",
  bootstrap.servers="localhost:9092",
  topic="alerts",
  is.binary.message='FALSE',
  @map(type='json')
)
define stream Alerts(user string, selection string);


define stream PriceChangesAboveThreshold(selection string, odds int);


-- SEE https://docs.wso2.com/display/SP420/Analyzing+Trends


-- Algorithm in pseudo code:
-- A) for each selection
-- B)   identify price increments exceeding threshold
-- C)   for each price, identify past bets placed before the price change within a window of time


-- A)
partition with (selection of PriceChanges)
begin

  -- B)
  --@info(name='PriceChangesAboveThreshold')
  from every previousChange=PriceChanges,
             latestChange=PriceChanges[odds > (previousChange.odds + 5)]
  select previousChange.selection, previousChange.odds
  insert into #PriceChangesAboveThreshold;
  -- todo detect total change across a larger number of changes
  -- sequence is probably not the best choice; window? table? pattern? aggregation (is time-unit based)?

  -- C)
  --@info(name='ShrewdBets')
      from #PriceChangesAboveThreshold#window.length(1) as priceChange unidirectional
      join Bets#window.time(10 sec) as bet -- real window likely larger
        on priceChange.selection == bet.selection
    select bet.user, bet.selection
    insert into Alerts;
    -- todo identify bets placed before offending change - need timestamp?

end;
